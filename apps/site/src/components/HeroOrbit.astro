---
/**
 * Silent binary-orbit micro-demo for the home hero.
 * Two stars orbit a shared barycenter on a <canvas>.
 * No controls, no annotations â€” just physics in motion.
 * Respects prefers-reduced-motion with a static snapshot.
 */
---

<canvas class="hero-orbit" aria-hidden="true"></canvas>

<style>
  .hero-orbit {
    width: 100%;
    height: 100%;
    min-height: 200px;
    display: block;
  }
</style>

<script>
  import { TwoBodyAnalytic } from "@cosmic/physics";

  // --- Inlined pure functions from binary-orbits/logic.ts ---
  // (We inline instead of importing because demos are a separate Vite build.)

  function clamp(v: number, lo: number, hi: number) {
    return Math.min(hi, Math.max(lo, v));
  }

  function bodyRadius(mass: number, base: number): number {
    if (mass <= 0 || base <= 0) return 0;
    return base * (1 + 0.25 * Math.log10(mass + 1));
  }

  interface BinaryModel {
    m1: number; m2: number; total: number;
    r1: number; r2: number;
    omegaRadPerYr: number;
  }

  function computeModel(massRatio: number, sepAu: number): BinaryModel {
    const m1 = 1;
    const m2 = clamp(massRatio, 0.2, 5);
    const total = m1 + m2;
    const sep = clamp(sepAu, 1, 8);
    const periodYr = TwoBodyAnalytic.orbitalPeriodYrFromAuSolar({
      aAu: sep, massSolar: total
    });
    const omega = periodYr > 0 ? (2 * Math.PI) / periodYr : 0;
    return {
      m1, m2, total,
      r1: sep * (m2 / total),
      r2: sep * (m1 / total),
      omegaRadPerYr: omega,
    };
  }

  // --- Canvas rendering ---

  const canvas = document.querySelector<HTMLCanvasElement>(".hero-orbit");
  if (!canvas) throw new Error("HeroOrbit: canvas not found");
  const ctx = canvas.getContext("2d");
  if (!ctx) throw new Error("HeroOrbit: 2d context unavailable");

  const model = computeModel(0.4, 3);
  const YEARS_PER_SEC = 0.06;
  const TRAIL_LENGTH = 90; // number of trail dots

  // Resolve CSS token colors once
  const style = getComputedStyle(document.documentElement);
  function cssVar(name: string) {
    return style.getPropertyValue(name).trim() || "transparent";
  }
  const COLOR_PRIMARY = cssVar("--cp-celestial-sun");
  const COLOR_SECONDARY = cssVar("--cp-accent");
  const COLOR_MUTED = cssVar("--cp-muted");
  const COLOR_GLOW = cssVar("--cp-glow-blue");

  // Trail buffers: ring buffers of {x, y}
  const trail1: { x: number; y: number }[] = [];
  const trail2: { x: number; y: number }[] = [];

  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    ctx!.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { w: rect.width, h: rect.height };
  }

  function draw(phaseRad: number) {
    const { w, h } = resize();
    const cx = w / 2;
    const cy = h / 2;
    ctx!.clearRect(0, 0, w, h);

    // Soft background glow
    const glow = ctx!.createRadialGradient(cx, cy, 0, cx, cy, Math.min(w, h) * 0.5);
    glow.addColorStop(0, COLOR_GLOW);
    glow.addColorStop(1, "transparent");
    ctx!.fillStyle = glow;
    ctx!.fillRect(0, 0, w, h);

    // Scale orbits to fit canvas
    const maxR = Math.max(model.r1, model.r2);
    const ppu = maxR > 0 ? (Math.min(w, h) * 0.36) / maxR : 1;
    const r1px = model.r1 * ppu;
    const r2px = model.r2 * ppu;

    // Body positions
    const cos = Math.cos(phaseRad);
    const sin = Math.sin(phaseRad);
    const x1 = cx - r1px * cos;
    const y1 = cy - r1px * sin;
    const x2 = cx + r2px * cos;
    const y2 = cy + r2px * sin;

    // Update trail buffers
    trail1.push({ x: x1, y: y1 });
    trail2.push({ x: x2, y: y2 });
    if (trail1.length > TRAIL_LENGTH) trail1.shift();
    if (trail2.length > TRAIL_LENGTH) trail2.shift();

    // Draw trails
    function drawTrail(trail: { x: number; y: number }[], color: string) {
      for (let i = 0; i < trail.length; i++) {
        const alpha = (i / trail.length) * 0.6;
        ctx!.fillStyle = color.startsWith("#")
          ? color + Math.round(alpha * 255).toString(16).padStart(2, "0")
          : color.replace(/[\d.]+\)$/, `${alpha})`);
        ctx!.beginPath();
        ctx!.arc(trail[i].x, trail[i].y, 1.5, 0, Math.PI * 2);
        ctx!.fill();
      }
    }
    drawTrail(trail1, COLOR_PRIMARY);
    drawTrail(trail2, COLOR_SECONDARY);

    // Barycenter cross
    ctx!.strokeStyle = COLOR_MUTED;
    ctx!.globalAlpha = 0.3;
    ctx!.lineWidth = 1;
    ctx!.beginPath();
    ctx!.moveTo(cx - 4, cy); ctx!.lineTo(cx + 4, cy);
    ctx!.moveTo(cx, cy - 4); ctx!.lineTo(cx, cy + 4);
    ctx!.stroke();
    ctx!.globalAlpha = 1;

    // Bodies with glow
    const base = Math.min(w, h) * 0.02;

    function drawBody(x: number, y: number, mass: number, color: string) {
      const r = bodyRadius(mass, base);
      // Glow
      const g = ctx!.createRadialGradient(x, y, 0, x, y, r * 3);
      g.addColorStop(0, color);
      g.addColorStop(1, "transparent");
      ctx!.fillStyle = g;
      ctx!.beginPath();
      ctx!.arc(x, y, r * 3, 0, Math.PI * 2);
      ctx!.fill();
      // Solid body
      ctx!.fillStyle = color;
      ctx!.beginPath();
      ctx!.arc(x, y, r, 0, Math.PI * 2);
      ctx!.fill();
    }
    drawBody(x1, y1, model.m1, COLOR_PRIMARY);
    drawBody(x2, y2, model.m2, COLOR_SECONDARY);
  }

  // Animation loop
  const prefersReducedMotion =
    window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  if (prefersReducedMotion) {
    // Pre-fill trail for static snapshot
    for (let i = 0; i < TRAIL_LENGTH; i++) {
      const phase = (i / TRAIL_LENGTH) * Math.PI * 1.5; // 270 deg of trail
      draw(phase);
    }
  } else {
    let lastTime = performance.now();
    let phaseRad = 0;
    function step(now: number) {
      const dt = Math.min((now - lastTime) / 1000, 0.1);
      lastTime = now;
      phaseRad += model.omegaRadPerYr * YEARS_PER_SEC * dt;
      draw(phaseRad);
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }
</script>
